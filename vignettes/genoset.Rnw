%\VignetteIndexEntry{genoset}
%\VignetteDepends{}
%\VignetteKeywords{genoset}
%\VignetteKeywords{bafset}
%\VignetteKeywords{cnset}
%\VignetteKeywords{BAFSet}
%\VignetteKeywords{CNSet}
%\VignettePackage{genoset}
\documentclass[10pt]{article}

\usepackage{times}
\usepackage{hyperref}
\usepackage{Sweave}

\newcommand{\Rfunction}[1]{{\texttt{#1}}} 
\newcommand{\Robject}[1]{{\texttt{#1}}} 
\newcommand{\Rpackage}[1]{{\textit{#1}}} 
\newcommand{\Rclass}[1]{{\textit{#1}}} 

\textwidth=6.5in
\textheight=8.5in
\oddsidemargin=-.1in
\evensidemargin=-.1in
\headheight=-.3in

\title{An Introduction to the ``genoset'' Package}
\author{Peter M. Haverty}
\date{\today}

\begin{document}
\maketitle
\tableofcontents
\newpage

<<<options,echo=FALSE>>=
  options(width=90)
@ 

\section{Introduction}
The genoset package offers an extension of the familiar Bioconductor eSet object for genome
assays, the GenoSet object. The principal addition of the GenoSet
class is the addition of location meta-data to the existing feature and phenotype meta-data. 
This 'locData' allows for various queries, summarization, plotting and subsetting operations 
by genome position. The genoset package also provides a number of convenient functions for working 
with data associated with with genome locations.

\subsection{Creating Objects}

In typical Bioconductor style, GenoSet objects can be created using the functions
with the same name.  Let's load up some fake data to experiment
with. Don't worry too much about how the fake data gets made. Notice how assayData
elements can be matrices or DataFrames with Rle columns (from IRanges). They can also
be BigMatrix or BigMatrixFactor objects (from bigmemoryExtras).

<<objectcreation>>=
library(genoset)
data(genoset)
gs = GenoSet( locData=locData.rd, cn=fake.cn, pData=fake.pData, annotation="SNP6" )
gs

rle.ds = GenoSet( locData=locData.rd,
  cn = fake.cn,
  cn.segments=DataFrame(K=Rle(c(rep(1.5,300),rep(2.3,700))),L=Rle( c(rep(3.2,700),rep(2.1,300)) ), M=Rle(rep(1.1,1000)),row.names=rownames(fake.cn)),
  pData=fake.pData,
  annotation="SNP6"
  )
@ 

Let's have look at what's inside these objects.

<<<objectinspection>>= >>=
slotNames(gs)
phenoData(gs)
pData(gs)
annotation(gs)
locData(gs)
@ 
Note that locData supplements, but does not replace featureData.

The assayData slot is a collection of equally sized matrix-like objects.

<<objectassaydata>>=
assayDataElementNames(rle.ds)
head( assayDataElement(rle.ds,"cn") )
@ 

\subsection{Accessing Genome Information}
Now lets look at some special functions for accessing genome
information from a genoset object. These functions are all defined for GenoSet, RangedData
and GRanges objects. We can access per-feature information
as well as summaries of chromosome boundaries in base-pair or
row-index units.

There are a number of functions for getting
portions of the locData data. ``chr'' and ``pos'' return the
chromosome and position information for each feature. ``genoPos'' is like ``pos'', but it
returns the base positions counting from the first base in the genome, with the
chromosomes in order by number and then alphabetically for the letter
chromosomes. ``chrInfo'' returns the genoPos of the first and last feature on each chromosome in
addition to the offset of the first feature from the start of the genome. ``chrInfo'' results are
used for drawing chromosome boundaries on genome-scale plots. ``pos''
and ``genoPos'' are defined as the floor of the average of each
features start and end positions.

<<accessgenomeinfo>>=
chrNames(gs)
chrOrder(c("chr12","chr12","chrX","chr8","chr7","chrY"))
chrInfo(gs)
chrIndices(gs)
elementLengths(gs)

head(chr(gs))
head(start(gs))
head(end(gs))
head(pos(gs))
tail(pos(gs))
tail(genoPos(gs))
@ 

\subsection{Genome Order}
GenoSet, GRanges, and RangedData objects can be set to and checked for genome
order. Weak genome order requires that features be ordered within each
chromosome. Strong genome order requires a certain order of chromosomes
as well. Features must be ordered so that features from the same
chromosome are in contiguous blocks.

Certain methods on GenoSet objects expect the rows to be in genome
order. Users are free to rearrange rows within
chromosome as they please, although if the locData is a RangedData,
this RangedData will prohibit mixing rows from different chromosomes.

The proper order of chromosomes is desirable for full-genome plots and is specified by the
``chrOrder'' function. The object creation method ``Genoset'' creates objects in strict genome order. 

<<genomeorder, eval=TRUE>>=
chrOrder(chrNames(gs))
isGenomeOrder(gs, strict=FALSE)
isGenomeOrder(gs, strict=TRUE)
gs = toGenomeOrder(gs, strict=TRUE)
isGenomeOrder(gs, strict=TRUE)
@

\subsection{Using the Subset Features}

GenoSet objects can be subset using matrix notation. The ``features''
index can be a set of ranges or the usual logical, numeric or character indices. chrIndices with a chromosome argument is
a convenient way to get the indices needed to subset by chromosome.

Subset by chromosome   
<<subsetbychr>>=
chr12.ds = gs[ chrIndices(gs,"chr12"), ]
chr12.ds
@ 

Subset by a collection of gene locations
<<subsetbygene>>=
gene.gr = GRanges(ranges=IRanges(start=c(35e6,127e6),end=c(35.5e6,129e6),                       
                       names=c("HER2","CMYC")), seqnames=c("chr17","chr8"))
gene.ds = gs[ gene.gr, ]
gene.ds
@ 

GenoSet objects can also be subset by a group of samples and/or
features, just like an ExpressionSet, or a matrix for that matter.

<<subsetsamples>>=
gs[1:4,1:2]
gs[ c("p1","p2"), c("E","F")]
@ 

eSet-derived classes tend to have special functions to get and set
specific assayDataElement members (the big data matrices). For
example, ExpressionSet has the ``exprs'' function. It is common to put
other optional matrices in assayData too (e.g. genotypes, quality
scores, etc.). These can be get and set with the ``assayDataElement''
function, but typing that out can get old.  GenoSet and derived
classes use the ``k'' argument to the matrix subsetting bracket to
subset from a specific assayDataElement. In addition to saving some
typing, you can directly use a set of ranges to subset the
assayDataElement.

<<subsetassaydata>>=
all( gs[ 1:4,1:2,"cn"] == assayDataElement(gs,"cn")[1:4,1:2] )
gs[ gene.gr, 1:2, "cn" ]
@ 

\section{Processing Data}

\subsection{Correction of Copy Number for local GC content}
Copy number data generally shows a GC content effect that appears as
slow ``waves'' along the genome (Diskin et al., NAR, 2008). The
function ``gcCorrect'' can be used to remove this effect resulting in
much clearer data and more accurate segmentation. GC content is best
measured as the gc content in windows around each feature, about 2Mb
in size.

<<GC, eval=FALSE>>=
library(BSgenome.Hsapiens.UCSC.hg19)
gc = rnorm(nrow(cn.ds))
gs[,,"cn"] = gcCorrect(gs[,,"cn"],gc)
@ 

\subsection{Segmentation}
Segmentation is the process of identifying blocks of the genome in
each sample that have the same copynumber value. It is a smoothing
method that attempts to replicate the biological reality where chunks
of chromosome have been deleted or amplified.

Genoset contains a convenience function for segmenting data for each sample/chr using the
DNACopy package (CBS).  GenoSet adds features to split jobs among
processor cores. When the library ``parallel'' is loaded, the
argument n.cores can control the number of processor cores
utilized.

Additionally, GenoSet stores segment values so that they can be
accessed quickly at both the feature and segment level. We use a
``DataFrame'' object from IRanges where each column is a
Run-Length-Encoded ``Rle'' object. This dramatically reduces the
amount of memory required to store the segments. Note how the segmented values
become just another member of the assayData slot.

Try running CBS directly
<<cbsdirect>>=
library(DNAcopy)
cbs.cna = CNA(gs[,,"cn"], chr(gs), pos(gs) )
cbs.smoothed.CNA = smooth.CNA( cbs.cna )
cbs.segs = segment( cbs.cna )
@ 

Or use the convenience function runCBS
<<runCBS>>=
gs[,,"cn.segs"] = runCBS(gs[,,"cn"],locData(gs))
@ 

Try it with multicore
<<cbsmulticore,eval=FALSE>>=
library(multicore)
gs[,,"cn.segs"] = runCBS(cn(cn.ds),locData(cn.ds), n.cores=3)
gs[,,"cn.segs"][1:5,1:3]
segTable( gs[,,"cn.segs"], locData(gs) )
@ 

Other segmenting methods can also be used of course. See "segs2Rle",
"segs2RleDataFrame", and "segs2RangedData" for ways to turn their
results into a DataFrame of Rle.

This function makes use of the multicore package to run things in
parallel, so plan ahead when picking ``n.cores''. Memory usage can be
a bit hard to predict.

\subsection{Segments as tables or runs}
Having segmented the data for each sample, you may want to explore different 
representations of the segments.

\subsection{Gene Level Summaries}
GenoSets contain feature level data. Often it is desirable to get
summaries of assayData matrices over an arbitrary set of ranges, like
exons, genes or cytobands. The function ``rangeSampleMeans'' serves this
purpose. Given a RangedData or GRanges of arbitrary genome ranges, a
GenoSet object, ``rangeSampleMeans'' will return a matrix of values
with a row for each range. 

``rangeSampleMeans'' uses ``boundingIndices'' to select the features 
bounding each range. The bounding features are the features with locations equal to or within the start
and end of the range. If no feature exactly matches the ends of the range, the nearest features outside 
the range will be used. This bounding ensures that the full extent of the
range is accounted for, and more importantly, at least two features
are included for each gene, even if the range falls between two
features.

``rangeColMeans'' is used to do a fast average of each of a
set of such bounding indices for each sample. These functions are
optimized for speed.  For example, with 2.5M features and ~750
samples, it takes 0.12 seconds to find the features bounded by all
Entrez Genes (one RefSeq each). Calculating the mean value for each
gene and sample takes ~9 seconds for a matrix of array data and ~30
seconds for a DataFrame of compressed Rle objects.

Generally, you will want to summarize segmented data and will be working with a 
DataFrame of Rle, like that returned by \code{runCBS}.

As an example, let's say you want to get the copynumber of your two
favorite genes from the subsetting example:

Get the gene-level summary:
<<genelevel, eval=TRUE>>=
boundingIndices( c(127e6,127.5e6), c(127e6,128e6), start(chr12.ds) )
rangeSampleMeans(gene.gr, baf.ds, "lrr")
@ 

\section{Plots}
Genoset has some handy functions for plotting data along the genome.
Segmented data ``knows'' it should be plotted as lines, rather than
points. One often wants to plot just one chromosome, so a convenience
argument for chromosome subsetting is provided. Like 'plot', ``genoPlot'' plots x against y. 
'x' can be some form of location data, like a GenoSet, RangedData, or GRanges. 'y' is some 
form of data along those coordinates, like a numeric vector or Rle. ``genoPlot'' marks 
chromosome boundaries and labels positions in ``bp'', ``kb'', ``Mb'', 
or ``Gb'' units as appropriate. Simple data and numeric position data 
can be plotted too.

<<fig=FALSE, echo=FALSE>>=
png(file="genoset-plotgenome.png",width=12,height=5,res=150,units="in")
@ 

<<plotgenome, echo=TRUE>>=
genoPlot(gs, gs[ , 1, "cn"])
genoPlot(gs, gs[, 1, "cn.segs"], add=TRUE, col="red")
@ 

<<fig=FALSE, echo=FALSE>>=
invisible(dev.off())
@ 

The result is shown in Fig.~\ref{plotgenome}.
\begin{figure}[tb]
  \begin{center}
     \includegraphics[width=0.85\textwidth]{genoset-plotgenome.png}  
     \caption{\label{plotgenome}%
     Segmented copy number across the genome for 1st sample}
  \end{center}
\end{figure}

<<fig=FALSE, echo=FALSE>>=
png(file="genoset-plotchr.png",width=12,height=5,res=150,units="in")
@ 

<<plotchr, echo=TRUE>>=
genoPlot(gs,gs[,1,"cn"],chr="chr12")
genoPlot(gs,gs[,1,"cn.segs"],chr="chr12",add=TRUE, col="red")
@ 

<<fig=FALSE, echo=FALSE>>=
invisible(dev.off())
@ 

The result is shown in Fig.~\ref{plotchr}.
\begin{figure}[tb]
  \begin{center}
     \includegraphics[width=0.85\textwidth]{genoset-plotchr.png}  
     \caption{\label{plotchr}%
     Segmented copy number across chromosome 12 for 1st sample}
  \end{center}
\end{figure}

Plot data without a GenoSet object using numeric or Rle data:
<<plotchrsimple, eval=FALSE>>=
chr12.ds = cn.ds[chr(cn.ds) == "chr12",]
genoPlot(pos(chr12.ds),chr12.ds)[,1,"cn"],locs=locData(chr12.ds))  # Numeric data and location
genoPlot(pos(chr12.ds),chr12.ds[,1,"cn.segs"],add=TRUE, col="red") # Rle data and numeric position
@ 

\section{CNSet and BAFSet Objects}
Two classes extend GenoSet: CNSet and BAFSet.  CNSet is the basic copy number object. It
requires that one assayDataElement be called ``cn'' slot, similar to the ExpressionSet uses ``exprs''.
BAFSet is intended to store ``LRR'' or Log-R Ratio and ``BAF'' or B-Allele Frequency data for
SNP arrays.  LRR and BAF come from the terms coined by Illumina and are discussed in Peiffer 
et al., 2008. LRR copy number data, basically log2(tumor/normal). BAF represents the fraction 
of signal coming from the ``B''
allele, relative to the ``A'' allele, where A and B are arbitrarily assigned. BAF has the
expected value of 0 or 1 for HOM alleles and 0.5 for HET alelles.  Deviation from these
expected values can be interpreted as Allelic Imbalance, which is a sign of gain, loss, or
copy-neutral LOH.  BAFSets require 'lrr' and 'baf' matrices as assayDataElements and have getter/setter 
methods for these elements.

\subsection{Creating CNSet and BAFSet Objects}
<<objectcreation>>=
library(genoset)
data(genoset)

baf.ds = BAFSet( locData=locData.rd, lrr=fake.lrr, baf=fake.baf, pData=fake.pData, annotation="SNP6" )
head( baf(baf.ds) )
head( lrr(baf.ds) )
cn.ds = CNSet( locData=locData.rd, cn=fake.lrr, pData=fake.pData, annotation="SNP6" )
head( cn(cn.ds) )
@

\subsection{Processing Data}
BAF data can be converted into the ``Modified BAF'' or mBAF metric, introduced by Staaf, et
al., 2008. mBAF folds the values around the 0.5 axis and makes the HOM positions NA.  The
preferred way to identify HOMs is to use genotype calls from a matched
normal (AA, AC, AG, etc.), but NA'ing greater than a certain value works OK.  A hom.cutoff of 0.90 is
suggested for Affymetrix arrays and 0.95 for Illumina arrays, following Staaf, et al.

Return data as a matrix:
<<mbafcutoff>>=
mbaf.data = baf2mbaf(baf(baf.ds),hom.cutoff = 0.90)
assayDataElement(baf.ds,"mbaf") = mbaf.data
@ 

... or use compress it to a DataFrame of Rle. This uses ~1/3 the space
on our random test data.
<<mbaftorle>>=
mbaf.data = DataFrame( sapply(colnames( mbaf.data),
  function(x) { Rle( mbaf.data[,x] ) },
  USE.NAMES=TRUE, simplify=FALSE ) )
as.numeric(object.size( assayDataElement(baf.ds,"mbaf")))  / as.numeric( object.size(mbaf.data))
@ 

Using the HOM SNP calls from the matched normal works much better. A
matrix of genotypes can be used to set the HOM SNPs to NA. A list of
sample names matches the columns of the genotypes to the columns of
your baf matrix. The names of the list should match column names in
your baf matrix and the values of the list should match the column
names in your genotype matrix.  If this method is used and some
columns in your baf matrix do not have an entry in this list, then
those baf columns are cleaned of HOMs using the hom.cutoff, as above.

Both mBAF and LRR can and should be segmented. Consider storing mBAF
as a DataFrame of Rle as only the ~1/1000 HET positions are being used
and all those NA HOM positions will compress nicely.

<<segment>>=
assayDataElement(baf.ds,"baf.segs") = runCBS( assayDataElement(baf.ds,"mbaf"), locData(baf.ds) )
assayDataElement(baf.ds,"lrr.segs") = runCBS( lrr(baf.ds), locData(baf.ds) )
@ 

\subsection{Plots}

<<fig=FALSE, echo=FALSE>>=
png(file="genoset-plotlrr.png",width=7,height=4,res=150,units="in")
@ 
<<plotlrr>>=
genoPlot(baf.ds,baf.ds[,1,"lrr"],chr="chr12",main="LRR of chr12")
genoPlot(baf.ds,baf.ds[,1,"lrr.segs"],chr="chr12",add=TRUE,col="red")
@
<<fig=FALSE, echo=FALSE>>=
invisible(dev.off())
@ 

The result is shown in Fig.~\ref{plotlrr}.
\begin{figure}[tb]
  \begin{center}
     \includegraphics[width=0.85\textwidth]{genoset-plotlrr.png}  
     \caption{\label{plotlrr}%
     Segmented copy number across the genome for 1st sample}
  \end{center}
\end{figure}


<<fig=FALSE, echo=FALSE>>=
png(file="genoset-plotbaf.png",width=7,height=8,res=150,units="in")
@ 
<<plotbaf, echo=TRUE>>=
par(mfrow=c(2,1))
genoPlot(baf.ds,baf.ds[,1,"baf"],chr="chr12", main="BAF of chr12")
genoPlot(baf.ds,baf.ds[,1,"mbaf"],chr="chr12", main="mBAF of chr12")
genoPlot(baf.ds,baf.ds[,1,"baf.segs"],chr="chr12", add=TRUE,col="red")
@ 
<<fig=FALSE, echo=FALSE>>=
invisible(dev.off())
@ 


The result is shown in Fig.~\ref{plotbaf}.
\begin{figure}[tb]
  \begin{center}
     \includegraphics[width=0.85\textwidth]{genoset-plotbaf.png}  
     \caption{\label{plotbaf}%
     Segmented copy number across the genome for 1st sample}
  \end{center}
\end{figure}

\section{Cross-sample summaries}
You can quickly calculate summaries across samples to identify regions
with frequent alterations.  A bit more care is necessary to work one
sample at a time if your data ``matrix'' is a DataFrame.

<<crosssample>>=
gain.list = lapply(sampleNames(baf.ds),
  function(sample.name) {
    as.logical( assayDataElement(baf.ds,"lrr.segs")[,sample.name] > 0.3 )
})
gain.mat = do.call(cbind, gain.list)
gain.freq = rowMeans(gain.mat,na.rm=TRUE)
@ 

GISTIC (by Behroukhim and Getz of the Broad Institute) is the standard 
method for assessing significance of such summaries. You'll find 
``segTable'' convenient for getting your data formatted for input. I 
find it convenient to load GISTIC output as a RangedData for 
intersection with gene locations.

\section{Big Data and bigmemory}
Genome-scale data can be huge and keeping everything in memory can get
you into trouble quickly, especially if you like using parallel's mclapply.

It is often convenient to use BigMatrix objects from the bigmemoryExtras
package as assayDataElements, rather than base matrices.  BigMatrix is
based on the bigmemory package, which provides a matrix API to
memory-mapped files of numeric data. This allows for data matrices
larger than R's maximum size with just the tiniest footprint in
RAM. The BigMatrix vignette has more details about using eSet-derived
classes and BigMatrix objects.

\end{document}
